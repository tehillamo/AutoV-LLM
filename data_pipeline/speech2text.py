from pydub import AudioSegment
import os
import sys
from argparse import ArgumentParser
import csv


def cut_audio(timestamps, audio):
    """
    Cuts an audio into segments based on the given timestamps.

    Parameters:
        timestamps (List[int]): A list of integers representing the timestamps in milliseconds.
        audio (AudioSegment): The audio to be cut.

    Returns:
        List[AudioSegment]: A list of AudioSegments representing the segmented audio.
    """
    audio_result = []
    for i, time in enumerate(timestamps):
        if i == len(timestamps) - 1:
            audio_result.append(audio[time:])
            break
        t1 = time
        t2 = timestamps[i+1]
        audio_result.append(audio[t1:t2])
    return audio_result

def read_timestamps(path):
    """
    Read timestamps from a file.

    Args:
        path (str): The path to the directory containing the timestamps file.

    Returns:
        list: A list of integers representing the timestamps.
    """
    with open(os.path.join(path, "timestamps.txt"), "r") as f:
        timestamps = f.readlines()
    return [int(x) for x in timestamps[0].split(",")]

def split_audio(uuid, path):
    """
    Generates audio segments by splitting a given audio file based on timestamps.

    Args:
        uuid (str): The unique identifier of the audio file.
        path (str): The path to the ressource directory.

    Returns:
        List[AudioSegment]: A list of audio segments generated by splitting the input audio file.
    """
    audio = AudioSegment.from_file(os.path.join(path, uuid, "audio.wav"))
    audios = cut_audio(read_timestamps(os.path.join(path, uuid)), audio)
    return audios

def save_audios_to_files(audios, path):
    """
    Save audios to files.

    Args:
        audios (List[AudioSegment]): A list of audio objects.
        path (str): The path where the audio files will be saved.

    Returns:
        None
    """
    for i, a in enumerate(audios):
        a.export(os.path.join(path, f'{i}.wav'), format="wav")

def create_csv(path, output_dir):
    """
    Creates a CSV file (in the current directory) containing transcribed text for each audio file in the given path.

    Parameters:
        path (str): The path to the directory containing the audio files.

    Returns:
        None
    """
    uuids = os.listdir(path)
    uuids.remove('.gitkeep')
    with open(os.path.join(output_dir, 'transcribed.csv'), 'w', newline='') as csvfile:
        writer = csv.writer(csvfile, delimiter=';', lineterminator='\r\n',
                                quotechar='"', quoting=csv.QUOTE_NONNUMERIC)
        writer.writerow(["uuid", "trial_number", "transcribed_text"])
        # For each uuid transcribe all trial audio recordings
        for uuid in uuids:
            print(uuid)
            paths = get_all_cutted_audios(os.path.join(path, uuid))
            transcribed = transcribe_audios(paths)
            for i, text in enumerate(transcribed):
                writer.writerow([str(uuid), int(i), str(text).strip()])
    
def get_all_cutted_audios(path):
    """
    Retrieves a list of all the cut audio files in the specified directory.

    Parameters:
        path (str): The path to the directory containing the audio files.

    Returns:
        list: A list of file paths for all the cut audio files in the directory.
    """
    files = []
    for file in os.listdir(path):
        if file.endswith(".wav") and not file.startswith("audio"):
            files.append(os.path.join(path, file))
    return files

def transcribe_audios(paths):
    """
    Transcribes a list of audio files using the Whisper library.

    Args:
        paths (List[str]): A list of file paths to audio files.

    Returns:
        List[str]: A list of transcribed text for each audio file.
    """
    import whisper
    # parameter which model to use
    model = whisper.load_model("base")
    transcribed = []
    for path in paths:
        res = model.transcribe(os.path.join(path), fp16=False)
        transcribed.append(res['text'])
    return transcribed

def main():
    # parse arguments
    parser = ArgumentParser(description="Splits an audio file into segments based on timestamps and transcribes each segment. The results are saved in a CSV file.")
    parser.add_argument("-p", "--path", dest="path", required=True, help="Path of ressource folder containing the folders with uuids")
    parser.add_argument("-t", "--transcribe", dest="transcribe", help="Transcribe audio (speech2text). This will also create a CSV file", action='store_true')
    parser.add_argument("-o", "--output-path", dest="output_path", help="Path of output folder", required=True)
    args = parser.parse_args()

    # find all uuids in ressource path
    uuids = os.listdir(args.path)
    uuids.remove('.gitkeep')
    print('Splitting audio...')
    for uuid in uuids:
        # split all audios into trial recordings
        print(uuid)
        audios = split_audio(uuid, args.path)
        save_audios_to_files(audios, os.path.join(args.path, uuid))

    if args.transcribe is True:
        # Transcribe all audios
        print('Transcribing audio...')
        create_csv(args.path, args.output_path)

if __name__ == "__main__":
    main()